var documenterSearchIndex = {"docs":
[{"location":"#Qiskit.jl","page":"Home","title":"Qiskit.jl","text":"Documentation for Qiskit.jl.\n\nThe documentation of Qiskit's C API may also be useful to reference when using this library.","category":"section"},{"location":"#API-Reference","page":"Home","title":"API Reference","text":"","category":"section"},{"location":"#Qiskit.QuantumCircuit","page":"Home","title":"Qiskit.QuantumCircuit","text":"QuantumCircuit\n\nQuantum circuit representation.\n\nAvailable read-only properties:\n\nnum_qubits\nnum_clbits\nnum_instructions\ndata - contains instruction list\n\nThe additional properties are methods:\n\nreset(qubit)\nmeasure(qubit, clbit)\nbarrier(qubit1, qubit2, ...)\nunitary(matrix, [qubit1, qubit2, ...])\nmany standard gates corresponding to Qiskit's Python API\n\n\n\n\n\n","category":"type"},{"location":"#Qiskit.SparseObservable","page":"Home","title":"Qiskit.SparseObservable","text":"SparseObservable\n\nQiskit observable.  This is a wrapper of QkObs, which is similar to SparseObservable in Python.\n\n\n\n\n\n","category":"type"},{"location":"#Qiskit.SparseObservable-Tuple{Integer}","page":"Home","title":"Qiskit.SparseObservable","text":"SparseObservable(n::Integer)\n\nConstruct an empty SparseObservable on n qubits.\n\n\n\n\n\n","category":"method"},{"location":"#Qiskit.Target","page":"Home","title":"Qiskit.Target","text":"Target\n\nA mapping of instructions and properties representing the particular constraints of a backend. Its purpose is to provide the compiler with information that allows it to compile an input circuit into another that is optimized taking in consideration the Target's specifications.\n\nAvailable properties:\n\nnum_qubits\nnum_instructions\n\n\n\n\n\n","category":"type"},{"location":"#Qiskit.Target-Tuple{Integer}","page":"Home","title":"Qiskit.Target","text":" Target(num_qubits)\n\n\n\n\n\n","category":"method"},{"location":"#Qiskit.TargetEntry","page":"Home","title":"Qiskit.TargetEntry","text":"TargetEntry\n\nA mapping of qubit arguments and properties representing gate map of the Target.\n\nAvailable properties:\n\nnum_properties\n\n\n\n\n\n","category":"type"},{"location":"#Qiskit.TranspileLayout","page":"Home","title":"Qiskit.TranspileLayout","text":"TranspileLayout\n\nThis type stores the permutation introduced by the transpiler. In general Qiskitâ€™s transpiler is unitary-preserving up to the initial layout and output permutations. The initial layout is the mapping from virtual circuit qubits to physical qubits on the target and the output permutation is caused by swap gate insertion or permutation elision prior to the initial layout being set in the transpiler pipeline. This type tracks these details and provide an interface to reason about these permutations.\n\n\n\n\n\n","category":"type"},{"location":"#Qiskit.transpile-Tuple{QuantumCircuit, Qiskit.Target}","page":"Home","title":"Qiskit.transpile","text":"transpile(circuit, target)\n\nTranspile a single circuit.\n\nThe Qiskit transpiler is a quantum circuit compiler that rewrites a given input circuit to match the constraints of a QPU and optimizes the circuit for execution.\n\nThis function wraps qk_transpile, which is multithreaded internally and will launch a thread pool with threads equal to the number of CPUs reported by the operating system by default. This will include logical cores on CPUs with simultaneous multithreading. You can tune the number of threads with the RAYON_NUM_THREADS environment variable. For example, setting RAYON_NUM_THREADS=4 would limit the thread pool to 4 threads.\n\n\n\n\n\n","category":"method"}]
}
